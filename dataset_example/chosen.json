{
"from": "gpt",
"value": "<think>首先，我需要理解这个问题。小渊和小轩坐在矩阵的对角线两端，需要传纸条。纸条只能向下或向右传递（从小渊到小轩），和向上或向左传递（从小轩到小渊）。但问题可以等效为从左上角到右下角找两条不相交的路径，使得路径上的好心程度之和最大。每个同学只能帮忙一次，所以两条路径不能有重叠的点（除了起点和终点）。\n\n关键点是：\n- 起点(1,1)和终点(m,n)的好心程度都是0，所以它们不影响总和，但可以被两条路径共享。\n- 需要找到两条不相交的路径最大化好心程度之和。\n\n我考虑不同的方法：\n1. 四维DP：直接记录两条路径的位置，但状态数太多（50^4 = 6.25百万），可能效率不高。\n2. 步数DP：由于两条路径都从(1,1)到(m,n)，步数相同，都是m+n-2步。可以用步数作为一维状态，减少状态数。\n\n我选择步数DP方法：\n- 定义f[k][i][j]表示两条路径都走了k步后，第一条路径在第i行，第二条路径在第j行时的最大和。\n- 由于步数相同，列号可以计算：c1 = k - i + 2, c2 = k - j + 2。\n- 为了确保路径不相交，我强制i ≤ j，并且当i = j时（同一个点）只允许在起点和终点出现。\n\n状态转移：\n从k-1步转移而来，每条路径有两种移动方式（向右或向下），所以有四种组合：\n1. 两条都向右：从f[k-1][i][j]转移\n2. 第一条向右，第二条向下：从f[k-1][i][j-1]转移\n3. 第一条向下，第二条向右：从f[k-1][i-1][j]转移\n4. 两条都向下：从f[k-1][i-1][j-1]转移\n\n我需要检查前驱状态的行号是否有效（在1到m之间），并且f[k-1][i1][j1]不为-1（表示有效状态）。\n\n最后，输出f[m+n-2][m][m]，即两条路径都到达终点时的最大和。\n\n让我用样例验证：\n输入：\n3 3\n0 3 9\n2 8 5\n5 7 0\n\n路径应该是：\n第一条： (1,1)→(1,2)→(1,3)→(2,3)→(3,3) \n第二条： (1,1)→(2,1)→(3,1)→(3,2)→(3,3)\n但这样有重叠点吗？实际上，点(3,3)是终点，共享没问题。好心程度：3+9+5+7 + 2+8+5? 等等，需要计算两条路径的总和。\n\n实际上，最优路径可能不同。根据输出34，我需要确保计算正确。\n\n在DP中，我们会考虑所有可能路径，所以应该能得到34。\n\n现在，实现代码。</think>\n```cpp\nm, n = map(int, input().split())\na = [[0] * (n + 1) for _ in range(m + 1)]\nfor i in range(1, m + 1):\n row = list(map(int, input().split()))\n for j in range(1, n + 1):\n a[i][j] = row[j - 1]\n\nsteps = m + n - 2\n# 初始化DP数组，-1表示无效状态\nf = [[[-1] * (m + 1) for _ in range(m + 1)] for _ in range(steps + 1)]\nf[0][1][1] = 0\n\nfor k in range(1, steps + 1):\n for i in range(1, m + 1):\n for j in range(i, m + 1): # j >= i 确保第一条路径在第二条路径上方\n # 如果i=j且不是最后一步（终点），跳过\n if i == j and k != steps:\n continue\n c1 = k - i + 2\n c2 = k - j + 2\n # 检查列号是否有效\n if c1 < 1 or c1 > n or c2 < 1 or c2 > n:\n continue\n \n best = -1\n # 1. 两条路径都向右\n if i <= m and j <= m:\n if f[k - 1][i][j] != -1:\n best = max(best, f[k - 1][i][j])\n # 2. 第一条向右，第二条向下\n if i <= m and j - 1 >= 1:\n if f[k - 1][i][j - 1] != -1:\n best = max(best, f[k - 1][i][j - 1])\n # 3. 第一条向下，第二条向右\n if i - 1 >= 1 and j <= m:\n if f[k - 1][i - 1][j] != -1:\n best = max(best, f[k - 1][i - 1][j])\n # 4. 两条路径都向下\n if i - 1 >= 1 and j - 1 >= 1:\n if f[k - 1][i - 1][j - 1] != -1:\n best = max(best, f[k - 1][i - 1][j - 1])\n \n if best == -1:\n continue\n f[k][i][j] = best + a[i][c1] + a[j][c2]\n\nprint(f[steps][m][m])\n```\n\n"
}